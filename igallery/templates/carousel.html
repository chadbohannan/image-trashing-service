{% extends "base.html" %}

{% block title %}Carousel - Image Trashing Service{% endblock %}

{% block extra_css %}
<style>
    .carousel-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #1a1a1a;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 100;
    }

    .carousel-image-wrapper {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .carousel-image {
        max-width: 90%;
        max-height: 90%;
        object-fit: contain;
    }

    .loading {
        color: #888;
        font-size: 1.5rem;
    }

    .hidden {
        display: none;
    }


    /* Bottom controls */
    .carousel-controls {
        position: fixed;
        bottom: 0;
        left: 0;
        background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
        padding: 30px;
        display: flex;
        flex-direction: column;
        gap: 15px;
        align-items: flex-start;
        z-index: 200;
        opacity: 0;
        transition: opacity 0.3s;
    }

    .carousel-controls.controls-visible {
        opacity: 1;
    }

    .control-row {
        display: flex;
        flex-direction: column-reverse;
        gap: 15px;
        align-items: flex-start;
    }


    .autoplay-controls {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 15px;
        background-color: rgba(42, 42, 42, 0.95);
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .autoplay-controls label {
        font-size: 14px;
        color: #e0e0e0;
        white-space: nowrap;
    }

    .autoplay-controls input[type="number"] {
        width: 50px;
        padding: 5px 8px;
        background-color: rgba(26, 26, 26, 0.8);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        color: #e0e0e0;
        text-align: center;
        font-size: 14px;
    }

    .control-btn {
        padding: 10px 20px;
        background-color: rgba(42, 42, 42, 0.95);
        color: #e0e0e0;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .control-btn:hover {
        background-color: rgba(74, 158, 255, 0.9);
        transform: translateY(-2px);
    }

    .control-btn.play {
        background-color: rgba(74, 158, 255, 0.95);
    }

    .control-btn.play.playing {
        background-color: rgba(40, 167, 69, 0.95);
    }

    .control-btn.trash {
        background-color: rgba(220, 53, 69, 0.95);
    }

    .control-btn.trash:hover {
        background-color: rgba(200, 35, 51, 0.95);
    }

    /* Navigation arrows */
    .carousel-nav {
        position: fixed;
        top: 50%;
        transform: translateY(-50%);
        color: white;
        font-size: 48px;
        cursor: pointer;
        padding: 20px;
        user-select: none;
        z-index: 200;
        opacity: 0;
        transition: opacity 0.3s, color 0.2s;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 50%;
        width: 70px;
        height: 70px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .carousel-nav.controls-visible {
        opacity: 0.7;
    }

    .carousel-nav:hover {
        opacity: 1 !important;
        color: #4a9eff;
    }

    .carousel-nav-prev {
        left: 30px;
    }

    .carousel-nav-next {
        right: 30px;
    }

    /* Close button */
    .carousel-close {
        position: fixed;
        top: 20px;
        right: 30px;
        color: white;
        font-size: 40px;
        cursor: pointer;
        z-index: 300;
        opacity: 0;
        transition: opacity 0.3s, color 0.2s;
    }

    .carousel-close.controls-visible {
        opacity: 0.7;
    }

    .carousel-close:hover {
        opacity: 1 !important;
        color: #4a9eff;
    }

    /* Trash button */
    .carousel-trash {
        position: fixed;
        bottom: 20px;
        right: 15px;
        color: white;
        font-size: 32px;
        cursor: pointer;
        z-index: 300;
        background-color: transparent;
        padding: 8px 16px;
        border-radius: 8px;
        opacity: 0;
        transition: opacity 0.3s;
    }

    .carousel-trash.controls-visible {
        opacity: 0.7;
    }

    .carousel-trash:hover {
        opacity: 1 !important;
    }

    .toast {
        position: fixed;
        bottom: 30px;
        right: 30px;
        background-color: #28a745;
        color: white;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 16px;
        z-index: 2000;
        opacity: 0;
        transform: translateY(20px);
        transition: opacity 0.3s, transform 0.3s;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .toast.show {
        opacity: 1;
        transform: translateY(0);
    }

    .toast-error {
        background-color: #dc3545;
    }

    /* Keyboard shortcuts help */
    .shortcuts-hint {
        position: fixed;
        top: 5px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(42, 42, 42, 0.95);
        color: #888;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 12px;
        z-index: 150;
        opacity: 0;
        transition: opacity 0.3s;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .shortcuts-hint.controls-visible {
        opacity: 1;
    }
</style>
{% endblock %}

{% block content %}
<div class="carousel-container">
    <!-- Close button -->
    <span class="carousel-close" onclick="closeCarousel()" title="Close (Esc)">√ó</span>
    <span class="carousel-trash" onclick="trashCurrentImage()" title="Move to trash (Backspace)">üóëÔ∏è</span>

    <!-- Main image area -->
    <div class="carousel-image-wrapper">
        <div class="loading" id="loading"></div>
        <img class="carousel-image hidden" id="carousel-image" src="" alt="">
    </div>

    <!-- Navigation arrows -->
    <span class="carousel-nav carousel-nav-prev" id="nav-prev" onclick="prevImage()" title="Previous (‚Üê)">‚Äπ</span>
    <span class="carousel-nav carousel-nav-next" id="nav-next" onclick="nextImage()" title="Next (‚Üí or Space)">‚Ä∫</span>

    <!-- Bottom controls -->
    <div class="carousel-controls" id="controls">
        <div class="control-row">
            <button class="control-btn play" id="play-btn" onclick="toggleAutoplay()" title="Play/Pause (P)">
                <span id="play-icon">‚ñ∂</span>
                <span id="play-text">Play</span>
            </button>

            <div class="autoplay-controls">
                <label>
                    Interval: <br>
                    <input type="number" id="interval-input" value="3" min="1" max="60" title="Autoplay interval in seconds">
                </label>
            </div>
        </div>
    </div>

    <!-- Keyboard shortcuts hint -->
    <div class="shortcuts-hint" id="shortcuts-hint">
        Space/‚Üí/Scroll‚Üì: Next ‚Ä¢ ‚Üê/Scroll‚Üë: Prev ‚Ä¢ P: Play/Pause ‚Ä¢ Backspace: Trash ‚Ä¢ Esc: Close
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
let currentImageName = null;
let currentImagePath = null;
let autoplayInterval = null;
let isPlaying = false;
let imageHistory = [];  // Track viewed images for back navigation
let historyIndex = -1;  // Current position in history
const currentPath = "{{ current_path }}";
let preloadedImage = null;  // Preloaded next image

function nextImage() {
    // If we're navigating back in history, just move forward
    if (historyIndex < imageHistory.length - 1) {
        historyIndex++;
        loadImageFromHistory(imageHistory[historyIndex]);
        return;
    }

    // Check if we have a preloaded image ready
    if (preloadedImage) {
        const loading = document.getElementById('loading');
        const image = document.getElementById('carousel-image');

        currentImageName = preloadedImage.name;
        currentImagePath = preloadedImage.path;

        // Use the actual URL (without preload flag) for display and history
        const displayUrl = preloadedImage.actualUrl || preloadedImage.url;

        // Add to history
        const imageData = {
            name: preloadedImage.name,
            path: preloadedImage.path,
            url: displayUrl
        };

        imageHistory.push(imageData);
        historyIndex = imageHistory.length - 1;

        // Record view on server by fetching the image without preload flag
        // This ensures the view is recorded when the user actually sees it
        fetch(displayUrl, { method: 'HEAD' }).catch(() => {
            // Ignore errors in view tracking
        });

        // Directly use the preloaded image element - it's already loaded!
        image.src = preloadedImage.img.src;
        loading.classList.add('hidden');
        image.classList.remove('hidden');

        // Preload the next image after current one is displayed
        preloadNextImage();

        // Clear the preloaded image
        preloadedImage = null;

        return;
    }

    // No preloaded image, fetch normally
    const loading = document.getElementById('loading');
    const image = document.getElementById('carousel-image');

    loading.classList.remove('hidden');
    image.classList.add('hidden');

    fetch(`/carousel/next?path=${currentPath}`)
        .then(response => {
            if (!response.ok) {
                return response.text().then(text => {
                    try {
                        const data = JSON.parse(text);
                        throw new Error(data.error || `Server error (${response.status})`);
                    } catch (parseError) {
                        if (text) {
                            throw new Error(`Server error (${response.status}): ${text.substring(0, 100)}`);
                        } else {
                            throw new Error(`Server error (${response.status}): Empty response`);
                        }
                    }
                });
            }
            return response.text().then(text => {
                if (!text) {
                    throw new Error('Empty response from server');
                }
                try {
                    return JSON.parse(text);
                } catch (e) {
                    throw new Error(`Invalid JSON response: ${text.substring(0, 100)}`);
                }
            });
        })
        .then(data => {
            if (data.error) {
                showToast(data.error, 'error');
                loading.classList.add('hidden');
                return;
            }

            currentImageName = data.image_name;
            currentImagePath = data.image_path;

            // Add to history
            const imageData = {
                name: data.image_name,
                path: data.image_path,
                url: data.image_url
            };

            // If we're at the end of history, add new image
            if (historyIndex === imageHistory.length - 1) {
                imageHistory.push(imageData);
                historyIndex = imageHistory.length - 1;
            } else {
                // If we're in the middle, truncate and add
                imageHistory = imageHistory.slice(0, historyIndex + 1);
                imageHistory.push(imageData);
                historyIndex = imageHistory.length - 1;
            }

            displayImage(data.image_url, data.image_name);
        })
        .catch(error => {
            showToast('Error loading image: ' + error.message, 'error');
            loading.classList.add('hidden');
        });
}

function prevImage() {
    if (historyIndex > 0) {
        historyIndex--;
        loadImageFromHistory(imageHistory[historyIndex]);
    }
}

function loadImageFromHistory(imageData) {
    currentImageName = imageData.name;
    currentImagePath = imageData.path;
    displayImage(imageData.url, imageData.name);
}

function displayImage(url, name) {
    const loading = document.getElementById('loading');
    const image = document.getElementById('carousel-image');

    image.src = url;
    image.onload = function() {
        loading.classList.add('hidden');
        image.classList.remove('hidden');

        // Preload the next image after current one is displayed
        preloadNextImage();
    };
}

function preloadNextImage() {
    // Only preload if we're at the end of history (forward navigation)
    if (historyIndex !== imageHistory.length - 1) {
        return; // Already have next image in history
    }

    // Fetch metadata for next image (with preload flag to avoid recording view)
    fetch(`/carousel/next?path=${currentPath}&preload=true`)
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                return; // Silently fail preload
            }

            // Create and preload the image
            // IMPORTANT: Add preload=true to image URL to prevent view recording
            const imageUrl = data.image_url + (data.image_url.includes('?') ? '&' : '?') + 'preload=true';
            preloadedImage = {
                name: data.image_name,
                path: data.image_path,
                url: imageUrl,
                actualUrl: data.image_url,  // Store the actual URL without preload flag
                img: new Image()
            };
            preloadedImage.img.src = imageUrl;
        })
        .catch(() => {
            // Silently fail preload
        });
}

function toggleAutoplay() {
    if (isPlaying) {
        stopAutoplay();
    } else {
        startAutoplay();
    }
}

function startAutoplay() {
    const intervalSeconds = parseInt(document.getElementById('interval-input').value) || 3;
    const intervalMs = intervalSeconds * 1000;

    // Load first image immediately if none loaded
    if (imageHistory.length === 0) {
        nextImage();
    }

    autoplayInterval = setInterval(nextImage, intervalMs);
    isPlaying = true;

    // Update UI
    const playBtn = document.getElementById('play-btn');
    const playIcon = document.getElementById('play-icon');
    const playText = document.getElementById('play-text');

    playBtn.classList.add('playing');
    playIcon.textContent = '‚è∏';
    playText.textContent = 'Pause';
}

function stopAutoplay() {
    if (autoplayInterval) {
        clearInterval(autoplayInterval);
        autoplayInterval = null;
    }
    isPlaying = false;

    // Update UI
    const playBtn = document.getElementById('play-btn');
    const playIcon = document.getElementById('play-icon');
    const playText = document.getElementById('play-text');

    playBtn.classList.remove('playing');
    playIcon.textContent = '‚ñ∂';
    playText.textContent = 'Play';
}

function closeCarousel() {
    window.location.href = `/?path=${currentPath}`;
}

function trashCurrentImage() {
    if (!currentImageName) {
        return;
    }

    const imageName = currentImageName;
    const fullImagePath = currentImagePath || '';

    // Extract directory path from full image path
    const lastSlash = fullImagePath.lastIndexOf('/');
    const dirPath = lastSlash !== -1 ? fullImagePath.substring(0, lastSlash) : '';

    fetch(`/trash?path=${dirPath}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ image_name: imageName })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Check if we're at the end of history (forward navigation position)
            const wasAtEnd = historyIndex === imageHistory.length - 1;

            // Remove current image from history
            if (historyIndex >= 0 && historyIndex < imageHistory.length) {
                imageHistory.splice(historyIndex, 1);
            }

            // After splice, check what's at the current position
            if (historyIndex < imageHistory.length && !wasAtEnd) {
                // There's already an image at this position (what was i+1 is now i)
                // This happens when navigating backward
                loadImageFromHistory(imageHistory[historyIndex]);
            } else {
                // We deleted while at the end (forward navigation) or history is empty
                // Check if we have a preloaded image ready (for fast loading)
                if (preloadedImage) {
                    const loading = document.getElementById('loading');
                    const image = document.getElementById('carousel-image');

                    currentImageName = preloadedImage.name;
                    currentImagePath = preloadedImage.path;

                    // Use the actual URL (without preload flag) for display and history
                    const displayUrl = preloadedImage.actualUrl || preloadedImage.url;

                    // Add to history
                    const imageData = {
                        name: preloadedImage.name,
                        path: preloadedImage.path,
                        url: displayUrl
                    };

                    imageHistory.push(imageData);
                    historyIndex = imageHistory.length - 1;

                    // Record view on server
                    fetch(displayUrl, { method: 'HEAD' }).catch(() => {});

                    // Directly use the preloaded image element - it's already loaded!
                    image.src = preloadedImage.img.src;
                    loading.classList.add('hidden');
                    image.classList.remove('hidden');

                    // Clear the preloaded image
                    preloadedImage = null;

                    // Preload the next image
                    preloadNextImage();
                } else {
                    // No preloaded image, fetch a new image
                    const loading = document.getElementById('loading');
                    const image = document.getElementById('carousel-image');

                    loading.classList.remove('hidden');
                    image.classList.add('hidden');

                    fetch(`/carousel/next?path=${currentPath}`)
                        .then(response => response.json())
                        .then(data => {
                            if (data.error) {
                                showToast(data.error, 'error');
                                loading.classList.add('hidden');
                                return;
                            }

                            currentImageName = data.image_name;
                            currentImagePath = data.image_path;

                            const imageData = {
                                name: data.image_name,
                                path: data.image_path,
                                url: data.image_url
                            };

                            imageHistory.push(imageData);
                            historyIndex = imageHistory.length - 1;

                            displayImage(data.image_url, data.image_name);
                        })
                        .catch(error => {
                            showToast('Error loading next image: ' + error.message, 'error');
                            loading.classList.add('hidden');
                        });
                }
            }
        } else {
            showToast('Error moving image to trash: ' + (data.error || 'Unknown error'), 'error');
        }
    })
    .catch(error => {
        showToast('Error: ' + error, 'error');
    });
}

function showToast(message, type = 'success') {
    // Remove existing toast if any
    const existingToast = document.querySelector('.toast');
    if (existingToast) {
        existingToast.remove();
    }

    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    toast.textContent = message;
    document.body.appendChild(toast);

    // Trigger animation
    setTimeout(() => toast.classList.add('show'), 10);

    // Remove after 3 seconds
    setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 300);
    }, 3000);
}

// Keyboard shortcuts
document.addEventListener('keydown', function(e) {
    switch(e.key) {
        case 'ArrowRight':
            e.preventDefault();
            nextImage();
            // Don't show controls when advancing with arrow
            break;
        case ' ':
            e.preventDefault();
            if (isPlaying) {
                stopAutoplay();
                showControls();
            } else {
                nextImage();
                // Don't show controls when advancing with spacebar
            }
            break;
        case 'ArrowLeft':
            e.preventDefault();
            prevImage();
            // Don't show controls when going back with arrow
            break;
        case 'p':
        case 'P':
            e.preventDefault();
            toggleAutoplay();
            showControls();
            break;
        case 'Delete':      // Forward delete (fn+delete on Mac)
        case 'Backspace':   // Backspace/delete on Mac
            e.preventDefault();
            if (isPlaying) {
                stopAutoplay();
            }
            trashCurrentImage();
            // Don't show controls when deleting
            break;
        case 'Escape':
            e.preventDefault();
            if (isPlaying) {
                stopAutoplay();
                showControls();
            } else {
                closeCarousel();
            }
            break;
    }
});

// Update interval when input changes during autoplay
document.getElementById('interval-input').addEventListener('change', function() {
    if (isPlaying) {
        stopAutoplay();
        startAutoplay();
    }
});

// Auto-hide controls after inactivity
let controlsTimeout;
let lastMouseMove = 0;

// Wheel event throttling
let lastWheelTime = 0;
let lastWheelDirection = 0; // Track last scroll direction: 1 for down, -1 for up
const WHEEL_THROTTLE_MS = 300; // Minimum time between wheel navigations

function showControls() {
    const controls = document.getElementById('controls');
    const navPrev = document.getElementById('nav-prev');
    const navNext = document.getElementById('nav-next');
    const shortcuts = document.getElementById('shortcuts-hint');
    const closeBtn = document.querySelector('.carousel-close');
    const trashBtn = document.querySelector('.carousel-trash');

    controls.classList.add('controls-visible');
    navPrev.classList.add('controls-visible');
    navNext.classList.add('controls-visible');
    shortcuts.classList.add('controls-visible');
    closeBtn.classList.add('controls-visible');
    trashBtn.classList.add('controls-visible');

    clearTimeout(controlsTimeout);
    controlsTimeout = setTimeout(() => {
        controls.classList.remove('controls-visible');
        navPrev.classList.remove('controls-visible');
        navNext.classList.remove('controls-visible');
        shortcuts.classList.remove('controls-visible');
        closeBtn.classList.remove('controls-visible');
        trashBtn.classList.remove('controls-visible');
    }, 2000);
}

// Show controls on mouse movement
document.addEventListener('mousemove', function() {
    const now = Date.now();
    // Only trigger if enough time has passed since last move (debounce)
    if (now - lastMouseMove > 100) {
        showControls();
        lastMouseMove = now;
    }
});

// Mouse wheel navigation (throttled)
document.addEventListener('wheel', function(e) {
    const now = Date.now();

    // Determine direction: positive deltaY = scroll down = next
    let currentDirection = 0;
    if (e.deltaY > 0) {
        currentDirection = 1;
    } else if (e.deltaY < 0) {
        currentDirection = -1;
    } else {
        return; // Ignore zero deltaY events
    }

    // Allow immediate navigation if direction changed, otherwise throttle
    const directionChanged = (lastWheelDirection !== 0 && currentDirection !== lastWheelDirection);
    if (!directionChanged && now - lastWheelTime < WHEEL_THROTTLE_MS) {
        return; // Throttle same-direction events
    }

    // Prevent default scrolling behavior
    e.preventDefault();

    // Update last wheel time and direction
    lastWheelTime = now;
    lastWheelDirection = currentDirection;

    if (currentDirection > 0) {
        nextImage();
    } else {
        prevImage();
    }
}, { passive: false }); // passive: false allows preventDefault()

// Note: We don't automatically show controls on ALL keydown events
// Individual key handlers decide whether to show controls

// Show controls on page load briefly
setTimeout(showControls, 100);

// Automatically load the first image when page loads
nextImage();
</script>
{% endblock %}
