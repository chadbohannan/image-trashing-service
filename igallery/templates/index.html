{% extends "base.html" %}

{% block title %}Gallery - Image Trashing Service{% endblock %}

{% block extra_css %}
<style>
    .folder-thumbnail {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
        background-color: #1a1a1a;
        cursor: pointer;
        overflow: hidden;
    }

    .folder-icon {
        font-size: 4rem;
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .folder-preview {
        flex: 1;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        padding: 8px;
    }

    .folder-preview img {
        width: 85%;
        height: 85%;
        object-fit: cover;
        border: 2px solid #444;
        border-radius: 4px;
    }

    .folder-name {
        width: 100%;
        padding: 6px 8px;
        margin-bottom: 8px;
        background-color: rgba(0, 0, 0, 0.7);
        color: #e0e0e0;
        font-size: 0.85rem;
        text-align: center;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        flex-shrink: 0;
        transform: translateY(-8px);
    }

    .folder-item-count {
        position: absolute;
        top: 8px;
        right: 8px;
        min-width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: rgba(0, 0, 0, 0.75);
        color: #e0e0e0;
        font-size: 0.95rem;
        font-weight: 600;
        padding: 4px 8px;
        border-radius: 6px;
        z-index: 10;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .folder-delete-overlay {
        position: absolute;
        top: 8px;
        right: 8px;
        min-width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #dc3545;
        color: white;
        padding: 4px 8px;
        border-radius: 6px;
        opacity: 0;
        transition: opacity 0.2s, background-color 0.2s;
        z-index: 20;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .thumbnail-item:hover .folder-delete-overlay {
        opacity: 1;
    }

    .folder-delete-icon {
        font-size: 20px;
        font-weight: bold;
        line-height: 1;
    }

    .folder-delete-overlay:hover {
        background-color: #c82333;
    }

    .thumbnail-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(125px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }

    .thumbnail-item {
        position: relative;
        background-color: #2a2a2a;
        border-radius: 8px;
        overflow: hidden;
        transition: transform 0.2s;
    }

    .thumbnail-item:hover {
        transform: scale(1.03);
    }

    .thumbnail-wrapper {
        position: relative;
        width: 100%;
        padding-top: 100%; /* 1:1 aspect ratio (square) */
        background-color: #1a1a1a;
    }

    .thumbnail-img {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: contain;
        cursor: pointer;
    }

    .thumbnail-actions {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        padding: 10px;
        background: linear-gradient(transparent, rgba(0,0,0,0.8));
        display: flex;
        justify-content: space-between;
        align-items: center;
        opacity: 0;
        transition: opacity 0.2s;
    }

    .thumbnail-item:hover .thumbnail-actions {
        opacity: 1;
    }

    .thumbnail-name {
        font-size: 0.85rem;
        color: white;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        flex: 1;
    }

    .trash-btn {
        background-color: #dc3545;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.85rem;
        transition: background-color 0.2s;
    }

    .trash-btn:hover {
        background-color: #c82333;
    }

    .empty-message {
        text-align: center;
        padding: 60px 20px;
        color: #888;
        font-size: 1.2rem;
    }

    .delete-folder-btn {
        margin-top: 20px;
        background-color: #dc3545;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 1rem;
        transition: background-color 0.2s;
    }

    .delete-folder-btn:hover {
        background-color: #c82333;
    }

    .lightbox {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.95);
        z-index: 1000;
        justify-content: center;
        align-items: center;
    }

    .lightbox.active {
        display: flex;
    }

    .lightbox img {
        max-width: 85%;
        max-height: 85%;
        object-fit: contain;
    }

    .lightbox-close {
        position: absolute;
        top: 20px;
        right: 30px;
        color: white;
        font-size: 40px;
        cursor: pointer;
        z-index: 1001;
    }

    .lightbox-close:hover {
        color: #4a9eff;
    }

    .lightbox-fullscreen {
        position: absolute;
        top: 20px;
        left: 30px;
        color: white;
        font-size: 32px;
        cursor: pointer;
        z-index: 1001;
        transition: color 0.2s;
    }

    .lightbox-fullscreen:hover {
        color: #4a9eff;
    }

    .lightbox-trash {
        position: absolute;
        bottom: 20px;
        right: 15px;
        color: white;
        font-size: 32px;
        cursor: pointer;
        z-index: 1001;
        background-color: transparent;
        padding: 8px 16px;
        border-radius: 8px;
        transition: opacity 0.2s;
    }

    .lightbox-trash:hover {
        opacity: 0.7;
    }

    .lightbox-move-up {
        position: absolute;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        font-size: 18px;
        cursor: pointer;
        z-index: 1001;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 50%;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: color 0.2s, opacity 0.2s;
    }

    .lightbox-move-up:hover {
        color: #4a9eff;
    }

    .lightbox-nav {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        color: white;
        font-size: 48px;
        cursor: pointer;
        padding: 20px;
        user-select: none;
        z-index: 1001;
        transition: color 0.2s, opacity 0.2s;
    }

    .lightbox-nav:hover {
        color: #4a9eff;
    }

    .lightbox-nav.disabled {
        opacity: 0.3;
        cursor: not-allowed;
    }

    .lightbox-nav.disabled:hover {
        color: white;
    }

    .lightbox-prev {
        left: 30px;
    }

    .lightbox-next {
        right: 30px;
    }

    .lightbox-counter {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        font-size: 16px;
        background-color: rgba(0, 0, 0, 0.6);
        padding: 8px 16px;
        border-radius: 20px;
        z-index: 1001;
    }

    .lightbox-filename {
        position: absolute;
        top: 30px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        font-size: 18px;
        background-color: rgba(0, 0, 0, 0.6);
        padding: 8px 16px;
        border-radius: 8px;
        z-index: 1001;
        max-width: 80%;
        text-align: center;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .toast {
        position: fixed;
        bottom: 30px;
        right: 30px;
        background-color: #28a745;
        color: white;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 16px;
        z-index: 2000;
        opacity: 0;
        transform: translateY(20px);
        transition: opacity 0.3s, transform 0.3s;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .toast.show {
        opacity: 1;
        transform: translateY(0);
    }

    .toast-error {
        background-color: #dc3545;
    }

    /* Keyboard shortcuts help */
    .shortcuts-hint {
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(42, 42, 42, 0.95);
        color: #888;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 12px;
        z-index: 1002;
        opacity: 0;
        transition: opacity 0.3s;
        border: 1px solid rgba(255, 255, 255, 0.1);
        pointer-events: none;
    }

    .shortcuts-hint.visible {
        opacity: 1;
    }
</style>
{% endblock %}

{% block nav_left %}
<div class="breadcrumb" style="margin: 0;">
    <a href="/">Home</a>
    {% for crumb in breadcrumbs %}
        <span>/</span>
        <a href="/?path={{ crumb.path }}">{{ crumb.name }}</a>
    {% endfor %}
</div>
{% endblock %}

{% block content %}
{% if items %}
<div class="images">
    {% if total_pages > 1 %}
    <div class="pagination">
        <a href="/?path={{ current_path }}&page={{ page - 1 }}&per_page={{ per_page }}" class="{% if page <= 1 %}disabled{% endif %}">‚Üê Previous</a>

        <span class="current">{{ page }}</span>
        <span>of {{ total_pages }}</span>

        <a href="/?path={{ current_path }}&page={{ page + 1 }}&per_page={{ per_page }}" class="{% if page >= total_pages %}disabled{% endif %}">Next ‚Üí</a>
    </div>
    {% endif %}
    <div class="thumbnail-grid" id="thumbnail-grid">
        {% for item in items %}
            {% if item.type == 'directory' %}
                <a href="/?path={{ (current_path + '/' + item.name) if current_path else item.name }}" class="thumbnail-item" data-type="directory" data-folder="{{ item.name }}" title="{{ item.name }}">
                    <div class="thumbnail-wrapper">
                        <div class="folder-thumbnail">
                            {% if item.first_image %}
                                <div class="folder-preview">
                                    <img src="/thumbnail/{{ (current_path + '/' + item.name + '/' + item.first_image) if current_path else (item.name + '/' + item.first_image) }}" alt="{{ item.name }}">
                                </div>
                            {% else %}
                                <span class="folder-icon">üìÅ</span>
                            {% endif %}
                            <span class="folder-name">{{ item.name }}</span>
                            {% if item.item_count is defined and item.item_count > 0 %}
                                <span class="folder-item-count">{{ item.item_count }}</span>
                            {% endif %}
                        </div>
                        {% if item.item_count is defined and item.item_count == 0 %}
                        <div class="folder-delete-overlay" onclick="deleteFolder('{{ item.name }}', event)">
                            <div class="folder-delete-icon">√ó</div>
                        </div>
                        {% endif %}
                    </div>
                </a>
            {% else %}
                <div class="thumbnail-item" data-image="{{ item.name }}" data-type="image">
                    <div class="thumbnail-wrapper">
                        <img
                            src="/thumbnail/{{ (current_path + '/' + item.name) if current_path else item.name }}"
                            alt="{{ item.name }}"
                            class="thumbnail-img"
                        >
                    </div>
                    <div class="thumbnail-actions">
                        <span class="thumbnail-name">{{ item.name }}</span>
                        <button class="trash-btn" onclick="trashImage('{{ item.name }}', event)">üóëÔ∏è</button>
                    </div>
                </div>
            {% endif %}
        {% endfor %}
    </div>
</div>
{% else %}
<div class="empty-message">
    <p>No items found in this directory.</p>
    {% if current_path %}
    <button class="delete-folder-btn" onclick="deleteCurrentFolder()">Delete Folder</button>
    {% endif %}
</div>
{% endif %}

<div id="lightbox" class="lightbox">
    <span class="lightbox-close" onclick="closeLightbox()" title="Close (Esc)">√ó</span>
    <span class="lightbox-fullscreen" onclick="toggleFullscreen()" title="Toggle fullscreen (F)">‚õ∂</span>
    <span class="lightbox-trash" onclick="trashCurrentLightboxImage(event)" title="Move to trash (Backspace)">üóëÔ∏è</span>
    <span class="lightbox-move-up" onclick="moveUpCurrentImage(event)" title="Move up one folder (‚Üë or U)">‚ñ≤</span>
    <span class="lightbox-nav lightbox-prev" id="lightbox-prev" onclick="prevImage(event)">‚Äπ</span>
    <img id="lightbox-img" src="" alt="" onclick="event.stopPropagation()">
    <span class="lightbox-nav lightbox-next" id="lightbox-next" onclick="nextImage(event)">‚Ä∫</span>

    <!-- Keyboard shortcuts hint -->
    <div class="shortcuts-hint" id="shortcuts-hint">
        ‚Üí/Space/Scroll‚Üì: Next ‚Ä¢ ‚Üê/Scroll‚Üë: Prev ‚Ä¢ ‚Üë/U: Move Up ‚Ä¢ Backspace: Trash ‚Ä¢ F: Fullscreen ‚Ä¢ Esc: Close
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// Calculate optimal per_page based on content width and thumbnail size
function calculatePerPage() {
    const thumbnailMinSize = 125; // minmax(125px, 1fr) from CSS
    const gap = 20; // gap from CSS

    // Get the actual width of the content container
    const contentWidth = document.querySelector('.container')?.offsetWidth || window.innerWidth;

    // Calculate how many thumbnails fit per row
    const thumbnailsPerRow = Math.floor((contentWidth + gap) / (thumbnailMinSize + gap));

    // Calculate for 4 rows minimum
    const calculatedPerPage = thumbnailsPerRow * 4;

    // Return at least 20
    return Math.max(calculatedPerPage, 20);
}

// Check if we need to reload with calculated per_page (after DOM is ready)
window.addEventListener('DOMContentLoaded', function() {
    const urlParams = new URLSearchParams(window.location.search);
    const calculatedPerPage = calculatePerPage();

    // If per_page is explicitly set in URL, keep that value
    // Otherwise, use calculated value and potentially reload
    if (urlParams.has('per_page')) {
        // User explicitly set per_page, don't change it
        optimalPerPage = parseInt(urlParams.get('per_page'));
    } else {
        // Use calculated value
        optimalPerPage = calculatedPerPage;
        const currentPerPage = parseInt(urlParams.get('per_page')) || 20;

        if (currentPerPage !== calculatedPerPage) {
            // Reload with optimal per_page
            urlParams.set('per_page', calculatedPerPage);
            window.location.search = urlParams.toString();
        }
    }
});

// Initialize variables for gallery and lightbox
let currentPage = {{ page }};
let totalPages = {{ total_pages }};
const currentPath = "{{ current_path }}";
let optimalPerPage = {{ per_page }}; // Will be updated on DOMContentLoaded if needed

// Build array of images for lightbox navigation
let galleryImages = [];

function updateGalleryImages(items) {
    galleryImages.length = 0;
    // Only include images, not directories
    items.forEach(item => {
        if (item.type === 'image') {
            galleryImages.push({
                name: item.name,
                url: `/image/${currentPath ? currentPath + '/' + item.name : item.name}`
            });
        }
    });
    initLightboxThumbnails();
}

// Initial population - only include images from items
updateGalleryImages([
    {% for item in items %}
        {% if item.type == 'image' %}
        {type: 'image', name: "{{ item.name }}"}{{ "," if not loop.last else "" }}
        {% endif %}
    {% endfor %}
]);

let currentImageIndex = 0;
let preloadedNextImage = null;  // Preloaded next image
let preloadedPrevImage = null;  // Preloaded previous image
let shortcutsHintShown = false;  // Track if shortcuts hint has been shown

// Wheel event throttling
let lastWheelTime = 0;
let lastWheelDirection = 0; // Track last scroll direction: 1 for down, -1 for up
const WHEEL_THROTTLE_MS = 300; // Minimum time between wheel navigations

function initLightboxThumbnails() {
    // Only attach handlers to image thumbnails, not directories
    const imageThumbnails = document.querySelectorAll('.thumbnail-item[data-type="image"] .thumbnail-img');
    imageThumbnails.forEach((thumbnail, index) => {
        thumbnail.onclick = (event) => openLightbox(index, event);
    });
}

function openLightbox(index, event) {
    if (event) event.stopPropagation();
    if (galleryImages.length === 0) return;

    currentImageIndex = index;
    updateLightboxImage();

    const lightbox = document.getElementById('lightbox');
    lightbox.classList.add('active');

    // Show shortcuts hint once for 5 seconds on first open
    if (!shortcutsHintShown) {
        const shortcutsHint = document.getElementById('shortcuts-hint');
        shortcutsHint.classList.add('visible');
        setTimeout(() => {
            shortcutsHint.classList.remove('visible');
        }, 5000);
        shortcutsHintShown = true;
    }

    // Record view
    recordImageView(galleryImages[currentImageIndex].name);
}

function closeLightbox() {
    const lightbox = document.getElementById('lightbox');
    lightbox.classList.remove('active');
}

function updateLightboxImage() {
    const img = document.getElementById('lightbox-img');
    const prevBtn = document.getElementById('lightbox-prev');
    const nextBtn = document.getElementById('lightbox-next');

    const currentImage = galleryImages[currentImageIndex];

    // Check if we have this image preloaded
    if (preloadedNextImage && preloadedNextImage.index === currentImageIndex) {
        // Use preloaded image
        img.src = preloadedNextImage.img.src;
        preloadedNextImage = null;
    } else if (preloadedPrevImage && preloadedPrevImage.index === currentImageIndex) {
        // Use preloaded image
        img.src = preloadedPrevImage.img.src;
        preloadedPrevImage = null;
    } else {
        // Load normally
        img.src = currentImage.url;
    }

    // Update button states
    if (currentImageIndex === 0 && currentPage === 1) {
        prevBtn.classList.add('disabled');
    } else {
        prevBtn.classList.remove('disabled');
    }

    if (currentImageIndex === galleryImages.length - 1 && currentPage === totalPages) {
        nextBtn.classList.add('disabled');
    } else {
        nextBtn.classList.remove('disabled');
    }

    // Preload adjacent images
    preloadAdjacentImages();
}

function preloadAdjacentImages() {
    // Preload next image
    if (currentImageIndex < galleryImages.length - 1) {
        const nextImage = galleryImages[currentImageIndex + 1];
        preloadedNextImage = {
            index: currentImageIndex + 1,
            img: new Image()
        };
        preloadedNextImage.img.src = nextImage.url;
    } else {
        preloadedNextImage = null;
    }

    // Preload previous image
    if (currentImageIndex > 0) {
        const prevImage = galleryImages[currentImageIndex - 1];
        preloadedPrevImage = {
            index: currentImageIndex - 1,
            img: new Image()
        };
        preloadedPrevImage.img.src = prevImage.url;
    } else {
        preloadedPrevImage = null;
    }
}

async function loadImagesForPage(pageNumber, initialImageIndex) {
    const perPage = optimalPerPage || 20;
    const response = await fetch(`/?path=${currentPath}&page=${pageNumber}&per_page=${perPage}&fetch_images_only=true`);
    const data = await response.json();

    if (data.success) {
        // Update the main thumbnail grid in the DOM
        const thumbnailGrid = document.getElementById('thumbnail-grid');
        thumbnailGrid.innerHTML = ''; // Clear existing thumbnails
        data.items.forEach(item => {
            if (item.type === 'directory') {
                // Create directory thumbnail
                const a = document.createElement('a');
                a.className = 'thumbnail-item';
                a.setAttribute('data-type', 'directory');
                a.setAttribute('data-folder', item.name);
                a.setAttribute('title', item.name);
                a.href = `/?path=${currentPath ? currentPath + '/' + item.name : item.name}`;

                const previewHtml = item.first_image
                    ? `<div class="folder-preview">
                        <img src="/thumbnail/${currentPath ? currentPath + '/' + item.name + '/' + item.first_image : item.name + '/' + item.first_image}" alt="${item.name}">
                       </div>`
                    : `<span class="folder-icon">üìÅ</span>`;

                const itemCountHtml = item.item_count && item.item_count > 0
                    ? `<span class="folder-item-count">${item.item_count}</span>`
                    : '';

                const deleteOverlayHtml = item.item_count === 0
                    ? `<div class="folder-delete-overlay" onclick="deleteFolder('${item.name}', event)">
                            <div class="folder-delete-icon">√ó</div>
                       </div>`
                    : '';

                a.innerHTML = `
                    <div class="thumbnail-wrapper">
                        <div class="folder-thumbnail">
                            ${previewHtml}
                            <span class="folder-name">${item.name}</span>
                            ${itemCountHtml}
                        </div>
                        ${deleteOverlayHtml}
                    </div>
                `;
                thumbnailGrid.appendChild(a);
            } else {
                // Create image thumbnail
                const div = document.createElement('div');
                div.className = 'thumbnail-item';
                div.setAttribute('data-image', item.name);
                div.setAttribute('data-type', 'image');
                div.innerHTML = `
                    <div class="thumbnail-wrapper">
                        <img
                            src="/thumbnail/${currentPath ? currentPath + '/' + item.name : item.name}"
                            alt="${item.name}"
                            class="thumbnail-img"
                        >
                    </div>
                    <div class="thumbnail-actions">
                        <span class="thumbnail-name">${item.name}</span>
                        <button class="trash-btn" onclick="trashImage('${item.name}', event)">üóëÔ∏è</button>
                    </div>
                `;
                thumbnailGrid.appendChild(div);
            }
        });

        updateGalleryImages(data.items); // Update the galleryImages array and re-init event listeners
        currentPage = data.page;
        totalPages = data.total_pages;
        currentImageIndex = (initialImageIndex === -1) ? galleryImages.length - 1 : initialImageIndex;

        // Clear preload cache when changing pages
        preloadedNextImage = null;
        preloadedPrevImage = null;

        updateLightboxImage();
        recordImageView(galleryImages[currentImageIndex].name);

        // Update the URL to reflect the new page
        const urlParams = new URLSearchParams(window.location.search);
        urlParams.set('page', currentPage);
        const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
        window.history.pushState({page: currentPage}, '', newUrl);

        // Update the pagination links at the bottom of the page
        const paginationDiv = document.querySelector('.pagination');
        if (paginationDiv) {
            const perPage = optimalPerPage || 20;
            let newPaginationHtml = '';

            // Previous button - always visible, disabled if on first page
            const prevDisabled = currentPage <= 1 ? 'disabled' : '';
            newPaginationHtml += `<a href="/?path=${currentPath}&page=${currentPage - 1}&per_page=${perPage}" class="${prevDisabled}">‚Üê Previous</a>`;

            newPaginationHtml += `<span class="current">${currentPage}</span>`;
            newPaginationHtml += `<span>of ${totalPages}</span>`;

            // Next button - always visible, disabled if on last page
            const nextDisabled = currentPage >= totalPages ? 'disabled' : '';
            newPaginationHtml += `<a href="/?path=${currentPath}&page=${currentPage + 1}&per_page=${perPage}" class="${nextDisabled}">Next ‚Üí</a>`;

            paginationDiv.innerHTML = newPaginationHtml;
        }

    } else {
        showToast(`Error loading images: ${data.error}`, 'error');
    }
}

async function prevImage(event) {
    if (event) event.stopPropagation();

    if (currentImageIndex > 0) {
        currentImageIndex--;
        updateLightboxImage();
        recordImageView(galleryImages[currentImageIndex].name);
    } else if (currentPage > 1) {
        // Load previous page, and set index to last image of that page
        await loadImagesForPage(currentPage - 1, -1); // -1 will be handled in loadImagesForPage to point to the last image
    }
}

async function nextImage(event) {
    if (event) event.stopPropagation();

    if (currentImageIndex < galleryImages.length - 1) {
        currentImageIndex++;
        updateLightboxImage();
        recordImageView(galleryImages[currentImageIndex].name);
    } else if (currentPage < totalPages) {
        // Load next page, and set index to first image of that page
        await loadImagesForPage(currentPage + 1, 0);
    }
}

function recordImageView(imageName) {
    const currentPath = "{{ current_path }}";
    // Silent request to record view
    const imagePath = currentPath ? `${currentPath}/${imageName}` : imageName;
    fetch(`/image/${imagePath}`, {
        method: 'HEAD'
    }).catch(() => {
        // Ignore errors in view tracking
    });
}

function trashCurrentLightboxImage(event) {
    if (event) event.stopPropagation();
    if (galleryImages.length > 0) {
        const currentImage = galleryImages[currentImageIndex];
        trashImage(currentImage.name, null, true);
    }
}

async function trashImage(imageName, event, fromLightbox = false) {
    if (event) event.stopPropagation();

    const currentPath = "{{ current_path }}";

    try {
        const response = await fetch(`/trash?path=${currentPath}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ image_name: imageName })
        });
        const data = await response.json();

        if (data.success) {
            // Remove thumbnail from page
            const item = document.querySelector(`[data-image="${imageName}"]`);
            if (item) {
                item.remove();
            }

            // Find index and determine if we're at the end BEFORE removal
            const index = galleryImages.findIndex(img => img.name === imageName);
            const wasAtEnd = (index !== -1 && index === galleryImages.length - 1);

            // Now remove from galleryImages array
            if (index !== -1) {
                galleryImages.splice(index, 1);
            }

            // Re-initialize lightbox click handlers with updated indices
            initLightboxThumbnails();

            // Check if page is now empty
            const remainingItems = document.querySelectorAll('.thumbnail-item');
            if (remainingItems.length === 0) {
                // Page is empty - navigate to previous page if possible
                if (fromLightbox && currentPage > 1) {
                    // Load previous page and open lightbox on last image
                    await loadImagesForPage(currentPage - 1, -1);
                    return;
                } else if (currentPage > 1) {
                    // Not in lightbox, just navigate to previous page
                    window.location.href = `/?path=${currentPath}&page=${currentPage - 1}&per_page=${optimalPerPage || 20}`;
                    return;
                } else {
                    // First page is empty, just reload
                    location.reload();
                    return;
                }
            }

            // Store count before fetching replacement
            const imagesBeforeReplace = galleryImages.length;

            // Fetch replacement image to maintain page size
            await fetchReplacementImage();

            // Handle lightbox index adjustment after replacement fetch
            if (fromLightbox) {
                if (galleryImages.length === 0) {
                    // No more images in current view, close lightbox
                    closeLightbox();
                    return;
                }

                const gotReplacement = (galleryImages.length > imagesBeforeReplace);

                // If we deleted the last image and got a replacement, stay at that index
                if (wasAtEnd && gotReplacement) {
                    // currentImageIndex stays the same (now points to replacement at end)
                    // Clear preload cache as we have a new image at this position
                    preloadedNextImage = null;
                    preloadedPrevImage = null;
                    updateLightboxImage();
                    recordImageView(galleryImages[currentImageIndex].name);
                }
                // If we deleted the last image but no replacement available
                else if (wasAtEnd && !gotReplacement) {
                    // Index is now out of bounds since we deleted the last item
                    // Need to navigate back
                    if (galleryImages.length > 0) {
                        // Still have images on current page, go to the new last image
                        currentImageIndex = galleryImages.length - 1;
                        // Check if we have the previous image preloaded (it's now at the new position)
                        if (preloadedPrevImage && preloadedPrevImage.index === currentImageIndex) {
                            // Keep it, it's the right image
                            preloadedNextImage = null;  // Clear next as it's no longer valid
                        } else {
                            // Clear both as we moved to a different position
                            preloadedNextImage = null;
                            preloadedPrevImage = null;
                        }
                        updateLightboxImage();
                        recordImageView(galleryImages[currentImageIndex].name);
                    } else if (currentPage > 1) {
                        // Page is empty, need to go to previous page
                        await loadImagesForPage(currentPage - 1, -1);
                    } else {
                        // Was the only image in the entire gallery
                        closeLightbox();
                    }
                }
                // Otherwise (didn't delete the last image), just update normally
                else {
                    // Adjust index if somehow out of bounds
                    if (currentImageIndex >= galleryImages.length) {
                        currentImageIndex = galleryImages.length - 1;
                    }
                    // Adjust preload cache: if we had preloaded next image (at old index+1),
                    // it's now at current index after deletion
                    if (preloadedNextImage && preloadedNextImage.index === index + 1) {
                        preloadedNextImage.index = index;
                    } else {
                        // If preloadedNextImage wasn't for the next image, clear it
                        preloadedNextImage = null;
                    }
                    // Previous image preload is no longer valid (indices shifted)
                    preloadedPrevImage = null;

                    updateLightboxImage();
                    recordImageView(galleryImages[currentImageIndex].name);
                }
            }
        } else {
            showToast('Error moving image to trash', 'error');
        }
    } catch (error) {
        showToast('Error: ' + error, 'error');
    }
}

async function fetchReplacementImage() {
    try {
        const perPage = optimalPerPage || 20;
        const response = await fetch(`/?path=${currentPath}&page=${currentPage}&per_page=${perPage}&fetch_images_only=true`);
        const data = await response.json();

        if (data.success) {
            // Find images in server response that we don't have yet
            const currentImageNames = new Set(galleryImages.map(img => img.name));
            const newItems = data.items.filter(item => item.type === 'image' && !currentImageNames.has(item.name));

            if (newItems.length > 0) {
                const thumbnailGrid = document.getElementById('thumbnail-grid');

                // Add each new image
                newItems.forEach(item => {
                    // Create new thumbnail
                    const div = document.createElement('div');
                    div.className = 'thumbnail-item';
                    div.setAttribute('data-image', item.name);
                    div.setAttribute('data-type', 'image');
                    div.innerHTML = `
                        <div class="thumbnail-wrapper">
                            <img
                                src="/thumbnail/${currentPath ? currentPath + '/' + item.name : item.name}"
                                alt="${item.name}"
                                class="thumbnail-img"
                            >
                        </div>
                        <div class="thumbnail-actions">
                            <span class="thumbnail-name">${item.name}</span>
                            <button class="trash-btn" onclick="trashImage('${item.name}', event)">üóëÔ∏è</button>
                        </div>
                    `;
                    thumbnailGrid.appendChild(div);

                    // Add to galleryImages array
                    galleryImages.push({
                        name: item.name,
                        url: `/image/${currentPath ? currentPath + '/' + item.name : item.name}`
                    });
                });

                // Re-initialize lightbox click handlers
                initLightboxThumbnails();
            }

            // Update total pages in case it changed
            if (data.total_pages !== undefined && data.total_pages !== totalPages) {
                totalPages = data.total_pages;
                if (fromLightbox) {
                    updateLightboxImage(); // Update navigation button states
                }
            }
        }
    } catch (error) {
        // Silently fail - page will just have fewer items
        console.error('Failed to fetch replacement image:', error);
    }
}

async function deleteFolder(folderName, event) {
    if (event) {
        event.stopPropagation();
        event.preventDefault();
    }

    const currentPath = "{{ current_path }}";

    try {
        const response = await fetch(`/folder/delete?path=${currentPath}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ folder_name: folderName })
        });
        const data = await response.json();

        if (data.success) {
            // Remove folder from the grid
            const folderItem = document.querySelector(`[data-folder="${folderName}"]`);
            if (folderItem) {
                folderItem.remove();
            }

            // Check if page is now empty
            const remainingItems = document.querySelectorAll('.thumbnail-item');
            if (remainingItems.length === 0) {
                // Reload the page to show empty state or previous page
                if (currentPage > 1) {
                    window.location.href = `/?path=${currentPath}&page=${currentPage - 1}&per_page=${optimalPerPage || 20}`;
                } else {
                    location.reload();
                }
            }
        } else {
            // Show error toast
            showToast(data.error || 'Error deleting folder', 'error');
        }
    } catch (error) {
        showToast('Error: ' + error, 'error');
    }
}

async function deleteCurrentFolder() {
    const currentPath = "{{ current_path }}";

    if (!currentPath) {
        showToast('Cannot delete root directory', 'error');
        return;
    }

    // Extract folder name and parent path
    const pathParts = currentPath.split('/');
    const folderName = pathParts.pop(); // Get last segment (current folder)
    const parentPath = pathParts.join('/'); // Join remaining segments

    try {
        const response = await fetch(`/folder/delete?path=${parentPath}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ folder_name: folderName })
        });
        const data = await response.json();

        if (data.success) {
            // Navigate up to parent directory
            if (parentPath) {
                window.location.href = `/?path=${parentPath}`;
            } else {
                window.location.href = '/';
            }
        } else {
            showToast(data.error || 'Error deleting folder', 'error');
        }
    } catch (error) {
        showToast('Error: ' + error, 'error');
    }
}

async function moveUpCurrentImage(event) {
    if (event) event.stopPropagation();
    if (galleryImages.length === 0) return;

    const currentImage = galleryImages[currentImageIndex];
    const currentPath = "{{ current_path }}";
    const imagePath = currentPath ? `${currentPath}/${currentImage.name}` : currentImage.name;

    try {
        const response = await fetch('/move-up', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ image_path: imagePath })
        });
        const data = await response.json();

        if (data.success) {
            // Remove image from current view (same logic as trash)
            const item = document.querySelector(`[data-image="${currentImage.name}"]`);
            if (item) {
                item.remove();
            }

            // Find index and determine if we're at the end BEFORE removal
            const index = currentImageIndex;
            const wasAtEnd = (index === galleryImages.length - 1);

            // Remove from galleryImages array
            galleryImages.splice(index, 1);

            // Re-initialize lightbox click handlers with updated indices
            initLightboxThumbnails();

            // Check if page is now empty
            const remainingItems = document.querySelectorAll('.thumbnail-item');
            if (remainingItems.length === 0) {
                // Page is empty - navigate to previous page if possible
                if (currentPage > 1) {
                    await loadImagesForPage(currentPage - 1, -1);
                    return;
                } else {
                    // First page is empty, close lightbox and reload
                    closeLightbox();
                    location.reload();
                    return;
                }
            }

            // Store count before fetching replacement
            const imagesBeforeReplace = galleryImages.length;

            // Fetch replacement image to maintain page size
            await fetchReplacementImage();

            // Handle lightbox navigation after move
            if (galleryImages.length === 0) {
                closeLightbox();
                return;
            }

            const gotReplacement = (galleryImages.length > imagesBeforeReplace);

            // If we moved the last image and got a replacement, show the replacement
            if (wasAtEnd && gotReplacement) {
                // currentImageIndex stays the same (now points to replacement at end)
                preloadedNextImage = null;
                preloadedPrevImage = null;
                updateLightboxImage();
                recordImageView(galleryImages[currentImageIndex].name);
            }
            // If we moved the last image but no replacement, go to previous
            else if (wasAtEnd && !gotReplacement) {
                if (galleryImages.length > 0) {
                    currentImageIndex = galleryImages.length - 1;
                    preloadedNextImage = null;
                    preloadedPrevImage = null;
                    updateLightboxImage();
                    recordImageView(galleryImages[currentImageIndex].name);
                } else if (currentPage > 1) {
                    await loadImagesForPage(currentPage - 1, -1);
                } else {
                    closeLightbox();
                }
            }
            // Otherwise, stay at current index (next image slides into place)
            else {
                if (currentImageIndex >= galleryImages.length) {
                    currentImageIndex = galleryImages.length - 1;
                }
                preloadedNextImage = null;
                preloadedPrevImage = null;
                updateLightboxImage();
                recordImageView(galleryImages[currentImageIndex].name);
            }
        } else {
            showToast(data.error || 'Error moving image', 'error');
        }
    } catch (error) {
        showToast('Error: ' + error, 'error');
    }
}

function showToast(message, type = 'success') {
    // Remove existing toast if any
    const existingToast = document.querySelector('.toast');
    if (existingToast) {
        existingToast.remove();
    }

    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    toast.textContent = message;
    document.body.appendChild(toast);

    // Trigger animation
    setTimeout(() => toast.classList.add('show'), 10);

    // Remove after 3 seconds
    setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 300);
    }, 3000);
}

function toggleFullscreen() {
    if (!document.fullscreenElement) {
        // Enter fullscreen
        document.documentElement.requestFullscreen().catch(err => {
            showToast(`Error entering fullscreen: ${err.message}`, 'error');
        });
    } else {
        // Exit fullscreen
        if (document.exitFullscreen) {
            document.exitFullscreen();
        }
    }
}

// Keyboard navigation
document.addEventListener('keydown', function(e) {
    const lightbox = document.getElementById('lightbox');
    const lightboxActive = lightbox.classList.contains('active');

    // Handle ESC key
    if (e.key === 'Escape') {
        e.preventDefault();
        if (lightboxActive) {
            // Close lightbox
            closeLightbox();
        } else {
            // Navigate back or to trash
            if (currentPath) {
                // In a subfolder - go back in history to preserve scroll position
                window.history.back();
            } else {
                // At root - go to trash
                window.location.href = '/trash-view';
            }
        }
        return;
    }

    // Handle keys in gallery view (lightbox not active)
    if (!lightboxActive) {
        switch(e.key) {
            case 'ArrowLeft':
                // Navigate to previous page
                if (currentPage > 1) {
                    e.preventDefault();
                    window.location.href = `/?path=${currentPath}&page=${currentPage - 1}&per_page=${optimalPerPage || 20}`;
                }
                break;
            case 'ArrowRight':
                // Navigate to next page
                if (currentPage < totalPages) {
                    e.preventDefault();
                    window.location.href = `/?path=${currentPath}&page=${currentPage + 1}&per_page=${optimalPerPage || 20}`;
                }
                break;
            case 'Enter':
                // Open first image in lightbox
                if (galleryImages.length > 0) {
                    e.preventDefault();
                    openLightbox(0);
                }
                break;
            case 'c':
            case 'C':
                // Navigate to carousel
                e.preventDefault();
                window.location.href = `/carousel?path=${currentPath}`;
                break;
        }
        return;
    }

    // Handle keys in lightbox view
    switch(e.key) {
        case 'ArrowLeft':
            prevImage();
            break;
        case 'ArrowRight':
        case ' ':
            e.preventDefault(); // Prevent space from scrolling
            nextImage();
            break;
        case 'ArrowUp':
            e.preventDefault(); // Prevent page scrolling
            moveUpCurrentImage(null);
            break;
        case 'Backspace':
        case 'Delete':
            e.preventDefault(); // Prevent browser back navigation
            if (galleryImages.length > 0) {
                const currentImage = galleryImages[currentImageIndex];
                trashImage(currentImage.name, null, true);
            }
            break;
        case 'u':
        case 'U':
            e.preventDefault();
            moveUpCurrentImage(null);
            break;
        case 'f':
        case 'F':
            e.preventDefault();
            toggleFullscreen();
            break;
        case 'c':
        case 'C':
            // Navigate to carousel
            e.preventDefault();
            window.location.href = `/carousel?path=${currentPath}`;
            break;
    }
});

// Mouse wheel navigation for lightbox (throttled)
document.addEventListener('wheel', function(e) {
    const lightbox = document.getElementById('lightbox');
    const lightboxActive = lightbox.classList.contains('active');

    // Only handle wheel events when lightbox is active
    if (!lightboxActive) {
        return;
    }

    const now = Date.now();

    // Determine direction: positive deltaY = scroll down = next
    let currentDirection = 0;
    if (e.deltaY > 0) {
        currentDirection = 1;
    } else if (e.deltaY < 0) {
        currentDirection = -1;
    } else {
        return; // Ignore zero deltaY events
    }

    // Allow immediate navigation if direction changed, otherwise throttle
    const directionChanged = (lastWheelDirection !== 0 && currentDirection !== lastWheelDirection);
    if (!directionChanged && now - lastWheelTime < WHEEL_THROTTLE_MS) {
        return; // Throttle same-direction events
    }

    // Prevent default scrolling behavior
    e.preventDefault();

    // Update last wheel time and direction
    lastWheelTime = now;
    lastWheelDirection = currentDirection;

    if (currentDirection > 0) {
        nextImage();
    } else {
        prevImage();
    }
}, { passive: false }); // passive: false allows preventDefault()

// Mouse button navigation for lightbox (back/forward buttons)
// Works in Chrome/Edge/Safari. Firefox blocks these events to protect browser navigation.
// Need to prevent default on all three events to stop browser navigation
['mousedown', 'mouseup', 'auxclick'].forEach(function(eventType) {
    document.addEventListener(eventType, function(e) {
        const lightbox = document.getElementById('lightbox');
        const lightboxActive = lightbox.classList.contains('active');

        // Only handle mouse button events when lightbox is active
        if (!lightboxActive) {
            return;
        }

        // Button 3 = Back button, Button 4 = Forward button
        if (e.button === 3 || e.button === 4) {
            e.preventDefault();
            e.stopPropagation();

            // Only navigate on mousedown to avoid duplicate navigation
            if (eventType === 'mousedown') {
                if (e.button === 3) {
                    prevImage();
                } else if (e.button === 4) {
                    nextImage();
                }
            }
        }
    }, true); // Capture phase
});
</script>
{% endblock %}
